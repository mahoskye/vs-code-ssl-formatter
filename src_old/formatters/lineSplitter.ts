import {
    CodeFormatter,
    FormatterInsight,
    TypedBlock,
    ContentSegment,
    ProcessedLine,
} from "./formattingPipeline";

/**
 * Represents information about an item list.
 */
interface ItemListInfo {
    /**
     * Indicates whether the item list is present.
     */
    hasList: boolean;

    /**
     * Specifies the type of the item list.
     *
     * - "tuple": The list represents tuple/positional arguments.
     * - "blockParameter": The list is a block parameter.
     * - "parameter": The list is a parameter.
     * - "array": The list is an array.
     * - "none": There is no list.
     */
    listType: "tuple" | "blockParameter" | "parameter" | "array" | "none";
}

/**
 * The `LineSplitter` class implements the `CodeFormatter` interface and is responsible for splitting lines of code
 * that exceed a specified maximum length. It provides methods to retrieve the formatter's name and insights, and to
 * format blocks of code by processing each line and logging relevant information.
 */
export class LineSplitter implements CodeFormatter {
    private insights: FormatterInsight[] = [];
    private maxLineLength: number;
    private itemsPerLine: number;

    /**
     * Creates an instance of the LineSplitter.
     *
     * @param maxLineLength - The maximum length of a line before it should be split.
     */
    constructor(maxLineLength: number, itemsPerLine: number) {
        this.maxLineLength = maxLineLength;
        this.itemsPerLine = itemsPerLine || 6;
    }

    /**
     * Returns the name of the formatter.
     *
     * @returns {string} The name of the formatter, which is "LineSplitter".
     */
    public getName(): string {
        return "LineSplitter";
    }

    /**
     * Retrieves the insights generated by the formatter.
     *
     * @returns {FormatterInsight[]} An array of formatter insights.
     */
    public getInsights(): FormatterInsight[] {
        try {
            return this.insights;
        } catch (e) {
            console.error(`Error retrieving insights: ${e}`);
            return [];
        }
    }

    /**
     * Formats the given blocks by processing each line and logging relevant information.
     *
     * @param blocks - An array of `TypedBlock` objects to be formatted.
     * @returns A promise that resolves when the formatting is complete.
     *
     * The method performs the following steps:
     * - Initializes the `insights` array.
     * - Logs the start of the formatting process with the maximum line length.
     * - Iterates over each block and logs the block type.
     * - For each line in the block, logs the line number, length of the formatted string, trimmed content, and whether it is considered a long line.
     */
    public async format(blocks: TypedBlock[]): Promise<void> {
        try {
            this.insights = [];
            console.debug(
                `\n[LineSplitter] Starting format with maxLineLength: ${this.maxLineLength}`
            );
            console.debug(`Items Per Line: ${this.itemsPerLine}`);

            for (const block of blocks) {
                console.debug(`\n[LineSplitter] Processing block of type: ${block.blockType}`);

                for (let i = 0; i < block.lines.length; i++) {
                    const line = block.lines[i];
                    console.debug(`[LineSplitter] Block Line ${i + 1}: \`${line.trimmedContent}\``);
                }

                for (let i = 0; i < block.lines.length; i++) {
                    const line = block.lines[i];
                    const splitType = this.getSplitType(block, line);
                    console.debug(
                        `\n[LineSplitter] Line ${line.lineNumber}: Length ${line.formattedString.length}`
                    );
                    console.debug(`Content: \`${line.trimmedContent}\``);
                    console.debug(`Split Type: ${splitType}`);

                    let contentToEvaluate = line.trimmedContent;
                    if (this.hasMultipleSemicolons(line)) {
                        console.debug(`Has Multiple Semicolons: ✅`);
                        // Process the block/segment up to the first semicolon
                        const segments = line.segments;
                        for (const segment of segments) {
                            if (segment.content.includes(";")) {
                                contentToEvaluate = segment.content.split(";")[0];
                                console.debug(
                                    `Content up to first semicolon: ${contentToEvaluate}`
                                );
                                break;
                            }
                        }
                    } else {
                        console.debug(`Has Multiple Semicolons: ❌`);
                    }

                    switch (splitType) {
                        case "comment":
                            console.debug(
                                `Is Comment Block: ${this.isCommentBlock(block) ? "✅" : "❌"}`
                            );
                            console.debug(
                                `Has Comment Segment: ${this.hasCommentSegment(line) ? "✅" : "❌"}`
                            );
                            break;
                        case "parameter":
                        case "blockParameter":
                        case "array":
                        case "tuple":
                            console.debug(`Is Long Line: ${this.isLongLine(line) ? "✅" : "❌"}`);
                            console.debug(
                                `Has Comment Segment: ${this.hasCommentSegment(line) ? "✅" : "❌"}`
                            );
                            const listInfo = this.containsItemList(block, line);
                            if (listInfo.hasList) {
                                console.debug(`Has List of Type: ${listInfo.listType}`);
                                console.debug(
                                    `List Items: ${
                                        listInfo.listType === "blockParameter" ? "🧀" : "🪰"
                                    } ${this.getListItems(block, listInfo.listType).join(
                                        listInfo.listType === "blockParameter" ? " 🐭 " : " 🐸 "
                                    )}`
                                );
                            } else {
                                console.debug("Has List: ⛔");
                            }
                            break;
                        case "concat":
                            console.debug(`Is Long Line: ${this.isLongLine(line) ? "✅" : "❌"}`);
                            console.debug(
                                `Has Comment Segment: ${this.hasCommentSegment(line) ? "✅" : "❌"}`
                            );
                            break;
                        default:
                            console.debug(`Is Long Line: ${this.isLongLine(line) ? "✅" : "❌"}`);
                            console.debug(
                                `Has Comment Segment: ${this.hasCommentSegment(line) ? "✅" : "❌"}`
                            );
                            break;
                    }
                }
            }
        } catch (e) {
            console.error(`Error formatting blocks: ${e}`);
        }
    }

    /**
     * Checks if the given line exceeds the maximum allowed length.
     *
     * @param line - The line to be checked, represented as a `ProcessedLine` object.
     * @returns `true` if the line's formatted string length is greater than the maximum line length, otherwise `false`.
     * @throws Will log an error to the console if an exception occurs during the check.
     */
    private isLongLine(line: ProcessedLine): boolean {
        try {
            return line.formattedString.length > this.maxLineLength;
        } catch (e) {
            console.error(`Error checking line length: ${e}`);
            return false;
        }
    }

    /**
     * Checks if the given line contains multiple semicolons.
     *
     * @param line - The line to be checked, represented as a `ProcessedLine` object.
     * @returns `true` if the line contains multiple semicolons, otherwise `false`.
     */
    private hasMultipleSemicolons(line: ProcessedLine): boolean {
        try {
            return line.trimmedContent.split(";").length > 2;
        } catch (e) {
            console.error(`Error checking for multiple semicolons: ${e}`);
            return false;
        }
    }

    /**
     * Checks if the given block is a comment block.
     *
     * @param block - The block to check.
     * @returns `true` if the block is a comment block, otherwise `false`.
     */
    private isCommentBlock(block: TypedBlock): boolean {
        try {
            return block.blockType === "comment";
        } catch (e) {
            console.error(`Error checking block type: ${e}`);
            return false;
        }
    }

    /**
     * Checks if the given line contains a comment segment.
     *
     * @param line - The line to be checked, represented as a `ProcessedLine` object.
     * @returns `true` if the line contains a comment segment, otherwise `false`.
     * @throws Will log an error to the console if an exception occurs during the check.
     */
    private hasCommentSegment(line: ProcessedLine): boolean {
        try {
            // Check if any segment in the line has the type `comment`
            return line.segments.some((segment: ContentSegment) => segment.type === "comment");
        } catch (e) {
            console.error(`Error checking line content: ${e}`);
            return false;
        }
    }

    /**
     * Checks if the given block contains a list.
     *
     * @param block - The block to be checked.
     * @returns `true` if the block contains a list, otherwise `false`.
     * @throws Will log an error to the console if an exception occurs during the check.
     */
    private hasList(block: TypedBlock): boolean {
        try {
            return block.lines.some((line: ProcessedLine) => {
                return this.containsItemList(block, line).hasList;
            });
        } catch (e) {
            console.error(`Error checking line content: ${e}`);
            return false;
        }
    }

    /**
     * Checks if the given code contains an item list.
     *
     * @param block - The block to be checked.
     * @returns Information about the item list.
     */
    private containsItemList(block: TypedBlock, line: ProcessedLine): ItemListInfo {
        try {
            // Check if this is a parameters or declare block
            const isParamBlock =
                block.blockType === "declaration" &&
                (block.metadata.declarationType === "parameters" ||
                    block.metadata.declarationType === "declare");

            if (isParamBlock) {
                return { hasList: true, listType: "blockParameter" };
            }

            // Flatten the block's lines into a single string for easier matching
            const code = block.lines.map((l) => l.trimmedContent).join("\n");

            const patterns = {
                arrayLists: /\{(?:[^{}]|\{[^{}]*\})*\}/g,
                parameterList: /\((?:[^()]|\([^()]*\))*\)/g,
                tupleList: /\[(?:[^\[\]]|\[[^\[\]]*\])*\]/g,
            };
            const cleanCode = ((str: string) => str.replace(/(["'`])(?:(?=(\\?))\2.)*?\1/g, ""))(
                code
            );

            const arrayMatches = cleanCode.match(patterns.arrayLists);
            const parameterMatches = cleanCode.match(patterns.parameterList);
            const tupleMatches = cleanCode.match(patterns.tupleList);

            if (arrayMatches && arrayMatches.length > 0) {
                return { hasList: true, listType: "array" };
            }
            if (parameterMatches && parameterMatches.length > 0) {
                return { hasList: true, listType: "parameter" };
            }
            if (tupleMatches && tupleMatches.length > 0) {
                return { hasList: true, listType: "tuple" };
            }

            return { hasList: false, listType: "none" };
        } catch (e) {
            console.error(`Error checking item list: ${e}`);
            return { hasList: false, listType: "none" };
        }
    }

    /**
     * Retrieves the opening and closing wrappers for the given list type.
     *
     * @param listType - The type of the list.
     * @returns An object containing the opening and closing wrappers for the list type.
     */
    private getListWrappers(listType: string): { open: string; close: string } {
        try {
            switch (listType) {
                case "array":
                    return { open: "{", close: "}" };
                case "parameter":
                    return { open: "(", close: ")" };
                case "tuple":
                    return { open: "[", close: "]" };
                default:
                    return { open: "", close: "" };
            }
        } catch (e) {
            console.error(`Error retrieving list wrappers: ${e}`);
            return { open: "", close: "" };
        }
    }

    /**
     * Retrieves the list items from the given block.
     *
     * @param block - The block to retrieve the list items from.
     * @param listType - The type of the list.
     * @returns An array of list items.
     */
    private getListItems(block: TypedBlock, listType: string): string[] {
        try {
            // If it's a parameter block or the listType is "parameter", process accordingly
            if (listType === "blockParameter") {
                return this.getParameterListItems(block, listType);
            }

            const items: string[] = [];
            const { open, close } = this.getListWrappers(listType);
            let depth = 0;
            let currentItem = "";
            let isInList = false;

            for (const line of block.lines) {
                for (const segment of line.segments) {
                    const content = segment.content.trim();

                    // Skip empty segments
                    if (!content) {
                        continue;
                    }

                    // Check if we're starting a list
                    if (content.includes(open)) {
                        depth++;
                        if (depth === 1) {
                            isInList = true;
                            currentItem += content.substring(content.indexOf(open) + 1); // Start after the opening character
                            continue; // Skip the opening character
                        }
                    }

                    // Check if we're ending a list
                    if (content.includes(close)) {
                        depth--;
                        if (depth === 0) {
                            const closingIndex = content.indexOf(close);
                            if (closingIndex > 0) {
                                currentItem += content.substring(0, closingIndex); // Add content before closing character
                            }
                            if (currentItem.trim()) {
                                items.push(currentItem.trim());
                            }
                            isInList = false;
                            currentItem = ""; // Reset for next list
                            continue;
                        }
                    }

                    // Process list items
                    if (isInList) {
                        if (
                            segment.tokenType?.type === "separator" &&
                            content === "," &&
                            depth === 1
                        ) {
                            // We've found a separator at the top level
                            if (currentItem.trim()) {
                                items.push(currentItem.trim());
                            }
                            currentItem = "";
                        } else {
                            // Add to current item, preserving nested structures
                            currentItem += content;
                        }
                    }
                }
            }

            // Clean up and normalize items
            return items.map((item) => item.trim()).filter((item) => item.length > 0);
        } catch (e) {
            console.error(`Error retrieving list items: ${e}`);
            return [];
        }
    }

    /**
     * Retrieves blockParameter list items from a declaration block.
     *
     * @param block - The block containing parameter declarations.
     * @returns An array of parameter items.
     */
    private getParameterListItems(block: TypedBlock, listType: string): string[] {
        try {
            const items: string[] = [];

            for (const line of block.lines) {
                for (const segment of line.segments) {
                    const content = segment.content.trim();

                    if (!content || segment.type === "comment") {
                        // Skip lines that don't contain actual parameters
                        continue;
                    }

                    if (segment.tokenType?.type === "separator" && content === ";") {
                        break;
                    }

                    // If segment is a separator
                    if (segment.tokenType?.type === "separator" && content === ",") {
                        continue;
                    }

                    if (["separator", "keyword"].includes(segment.tokenType.type)) {
                        continue;
                    }

                    if (!["separator", "keyword"].includes(segment.tokenType.type)) {
                        items.push(content);
                        continue;
                    }
                }
            }
            // Clean up and normalize items
            return items.map((item) => item.trim()).filter((item) => item.length > 0);
        } catch (e) {
            console.error(`Error retrieving list items: ${e}`);
            return [];
        }
    }

    private getSplitType(block: TypedBlock, line: ProcessedLine): string {
        try {
            // First check for list types since those represent the main code structure
            const listInfo = this.containsItemList(block, line);
            if (listInfo.hasList) {
                return listInfo.listType;
            }

            // Check for string concatenation
            const hasConcat = line.segments.some(
                (segment) =>
                    segment.tokenType?.type === "operator" && segment.content.trim() === "+"
            );
            if (hasConcat) {
                return "concat";
            }

            // If no code-specific split types are found, check if it's a pure comment
            if (this.isCommentBlock(block) || this.isOnlyComment(line)) {
                return "comment";
            }

            return "none";
        } catch (e) {
            console.error(`Error determining split type: ${e}`);
            return "none";
        }
    }

    /**
     * Determines if a line contains only comment content.
     * @param line - The line to check
     * @returns true if the line contains only comments and no code
     */
    private isOnlyComment(line: ProcessedLine): boolean {
        try {
            // Filter out empty/whitespace segments
            const nonEmptySegments = line.segments.filter(
                (segment) => segment.type !== "empty" && segment.content.trim().length > 0
            );

            // Check if all non-empty segments are comments
            return (
                nonEmptySegments.length > 0 &&
                nonEmptySegments.every((segment) => segment.type === "comment")
            );
        } catch (e) {
            console.error(`Error checking if line is only comment: ${e}`);
            return false;
        }
    }
}
