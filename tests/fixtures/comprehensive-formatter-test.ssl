/*******************************************************************************
SSL Comprehensive Formatter Test Document
Description.. : Complete test of SSL formatter with all keywords and styles
Parameters... : None (module-level test)
Returns...... : None (documentation/testing only)
Author....... : Formatter Test Suite
Date......... : 2025-11-13
*******************************************************************************/;

:INCLUDE "external-library";
:INCLUDE "common-utilities";

/* External library includes complete;

:DECLARE aGlobalArray, nGlobalCounter, sGlobalMessage;
:DEFAULT nGlobalCounter, 0;
:DEFAULT sGlobalMessage, "Test";

/* region Conditional Logic Tests;

:PROCEDURE TestIfElseNesting;
:PARAMETERS nValue;
:DECLARE nResult, bProcessed;
/* Test nested IF/ELSE structures;
	:IF nValue > 100;
		bProcessed := .T.;
		nResult := nValue * 2;
		:IF nValue > 200;
			nResult := nResult + 50;
		:ELSE;
			nResult := nResult - 25;
		:ENDIF;
	:ELSE;
		:IF nValue > 50;
			nResult := nValue + 100;
			bProcessed := .T.;
		:ELSE;
			nResult := 0;
			bProcessed := .F.;
		:ENDIF;
	:ENDIF;
:RETURN nResult;
:ENDPROC;

/* endregion;

/* region Loop Control Tests;

:PROCEDURE TestForLoopWithStep;
:PARAMETERS aItems;
:DECLARE nIndex, nTotal, nStep;
	nTotal := 0;
	nStep := 2;
/* Test FOR loop with STEP and EXITFOR;
	:FOR nIndex := 1 :TO Len(aItems):STEP nStep;
		:IF aItems[nIndex] == NIL;
			:EXITFOR;
		:ENDIF;
		nTotal := nTotal + aItems[nIndex];
	:NEXT;
:RETURN nTotal;
:ENDPROC;

:PROCEDURE TestWhileLoopWithExitwhile;
:PARAMETERS nStartValue;
:DECLARE nCounter;
	nCounter := nStartValue;
/* Test WHILE loop with EXITWHILE;
	:WHILE nCounter < 100;
		:IF nCounter == 50;
			:EXITWHILE;
		:ENDIF;
		nCounter := nCounter + 1;
	:ENDWHILE;
:RETURN nCounter;
:ENDPROC;

:PROCEDURE TestLoopKeyword;
:PARAMETERS nMaxIterations;
:DECLARE nIteration;
	nIteration := 0;
/* Test LOOP keyword with conditional exit;
	:LOOP;
	nIteration := nIteration + 1;
	:IF nIteration >= nMaxIterations;
		:EXITWHILE;
	:ENDIF;
:ENDWHILE;
:RETURN nIteration;
:ENDPROC;

/* endregion;

/* region Case Statement Tests;

:PROCEDURE TestCaseStatement;
:PARAMETERS sInputValue;
:DECLARE nReturnCode;
/* Test BEGINCASE/CASE/OTHERWISE/ENDCASE structure;
	:BEGINCASE;
	:CASE sInputValue == "START";
		nReturnCode := 1;
	:CASE sInputValue == "STOP";
		nReturnCode := 0;
	:CASE sInputValue == "PAUSE";
		nReturnCode := 2;
	:CASE sInputValue == "RESUME";
		nReturnCode := 3;
	:OTHERWISE;
		nReturnCode := -1;
		:EXITCASE;
	:ENDCASE;
:RETURN nReturnCode;
:ENDPROC;

/* endregion;

/* region Error Handling Tests;

:PROCEDURE TestTryCatchFinally;
:PARAMETERS sSqlQuery;
:DECLARE aResultSet, sErrorMessage;
/* Test TRY/CATCH/FINALLY/ENDTRY error handling;
	:TRY;
		aResultSet := SQLExecute(sSqlQuery, "query", 0, 0, 0, "", "", "", 0);
		:IF Len(aResultSet) == 0;
			:ERROR "No results returned";
		:ENDIF;
	:CATCH;
		sErrorMessage := GetLastSSLError();
/* Handle error;
		aResultSet := {};
	:FINALLY;
/* Cleanup operations;
		:IF .NOT. Empty(aResultSet);
/* Process results;
		:ENDIF;
	:ENDTRY;
:RETURN aResultSet;
:ENDPROC;

/* endregion;

/* region Operators and Expressions Tests;

:PROCEDURE TestOperatorsAndExpressions;
:PARAMETERS nA, nB, sValue;
:DECLARE nResult, bCondition, sOutput;
/* Test all operator types with proper spacing;

/* Assignment operators;
	nResult := nA;
	nResult += nB;
	nResult -= 5;
	nResult *= 2;
	nResult /= 3;
	nResult ^= 2;
	nResult %= 7;

/* Comparison operators;
	bCondition := nA == nB;
	bCondition := nA != nB;
	bCondition := nA <> nB;
	bCondition := nA < nB;
	bCondition := nA > nB;
	bCondition := nA <= nB;
	bCondition := nA >= nB;
	bCondition := nA # nB;

/* Logical operators;
	bCondition := nA > 0 .AND. nB < 100;
	bCondition := nA > 0 .OR. nB < 100;
	bCondition := .NOT. (nA == nB);

/* String concatenation;
	sOutput := "Result: " + Trim(sValue);

/* Prefix and postfix operators;
	nA++;
	nB--;
	++nResult;
	--nResult;

:RETURN nResult;
:ENDPROC;

/* endregion;

/* region Boolean and Null Values Tests;

:PROCEDURE TestBooleanAndNullValues;
:DECLARE bTrue, bFalse, oNilValue;
/* Test boolean literals (.T. and .F.);
	bTrue := .T.;
	bFalse := .F.;

/* Test NIL literal;
	oNilValue := NIL;

	:IF bTrue;
/* Boolean true;
	:ENDIF;

	:IF .NOT. bFalse;
/* Boolean false negation;
	:ENDIF;

	:IF Empty(oNilValue);
/* NIL is empty;
	:ENDIF;

:RETURN bTrue;
:ENDPROC;

/* endregion;

/* region Array and String Operations;

:PROCEDURE TestArraysAndStrings;
:PARAMETERS sInput;
:DECLARE aStringArray, nPosition, sSubstring;
/* Test array literal syntax;
	aStringArray := {"alpha", "beta", "gamma", "delta"};

/* Test array functions;
	aadd(aStringArray, "epsilon");
	nPosition := ascan(aStringArray, "beta");

/* String operations;
	sSubstring := SubStr(sInput, 1, 5);
	nPosition := At("test", sInput);
	sInput := AllTrim(sInput);
	sInput := Upper(sInput);
	sInput := Lower(sInput);

:RETURN aStringArray;
:ENDPROC;

/* endregion;

/* region Date and Time Operations;

:PROCEDURE TestDateAndTime;
:DECLARE dToday, dSpecificDate, nDayDifference;
/* Test date functions;
	dToday := Today();
	dToday := Now();

/* Date literal syntax;
	dSpecificDate := {2025, 11, 13};
	dSpecificDate := {2025, 11, 13, 14, 30, 0};

/* Date calculations;
	nDayDifference := DateDiff(dToday, dSpecificDate);
	dSpecificDate := DateAdd(dToday, 30);

:RETURN nDayDifference;
:ENDPROC;

/* endregion;

/* region Database and SQL Tests;

:PROCEDURE TestDatabaseOperations;
:PARAMETERS sTableName, nRecordId;
:DECLARE aQueryResult, sSelectQuery, sUpdateQuery;
/* Test SQLExecute with parameters;
	sSelectQuery := "SELECT field1, field2 FROM " + sTableName + " WHERE id = ?id?";
	aQueryResult := SQLExecute(sSelectQuery, "select_query", 0, 0, 0, "", "", "", 1);

/* Alternative query with positional parameters;
	sSelectQuery := "SELECT * FROM " + sTableName + " WHERE status = ?";
	aQueryResult := SQLExecute(sSelectQuery, "param_query", 0, 0, 0, "", "", "", 0);

/* Test RunSQL for modifications;
	sUpdateQuery := "UPDATE " + sTableName + " SET status = 'active' WHERE id = ?id?";
	RunSQL(sUpdateQuery, "update_query");

/* Test LSearch for single result;
	aQueryResult := LSearch("SELECT TOP 1 value FROM " + sTableName);

:RETURN aQueryResult;
:ENDPROC;

/* endregion;

/* region Function Calls and Procedures;

:PROCEDURE TestFunctionCalls;
:PARAMETERS nValue;
:DECLARE nLength, bIsEmpty, nAbsoluteValue, sCharacter;
/* Test built-in function calls with proper formatting;
	nLength := Len("test string");
	bIsEmpty := Empty(nValue);
	nAbsoluteValue := Abs(nValue);
	sCharacter := Chr(65);

/* Test procedure call with DOPROC;
	DoProc("ExternalProcedure", {nValue, "parameter"});

/* Test EXECFUNCTION;
	ExecFunction("CalculateTotal", {10, 20, 30});

/* Test array operations;
	aadd(aGlobalArray, nValue);
	alen(aGlobalArray);
	ascan(aGlobalArray, nValue);
	aeval(aGlobalArray, TestFunctionCalls);

:RETURN bIsEmpty;
:ENDPROC;

/* endregion;

/* region Object-Oriented Programming Tests;

:PROCEDURE TestObjectOperations;
:DECLARE oUserObject, oDataSet, sUserName;
/* Test UDO creation;
	oUserObject := CreateUdoObject("UserAccount");

/* Test object property access;
	sUserName := oUserObject:UserName;
	oUserObject:UserName := "John Doe";

/* Test object method calls;
	oDataSet := oUserObject:GetDataset();
	oUserObject:Save();
	oUserObject:Initialize("NewUser", "user@example.com");

:RETURN oUserObject;
:ENDPROC;

/* endregion;

/* region DECLARE and PUBLIC Variables;

:PROCEDURE TestVariableDeclarations;
:PARAMETERS nPublicParam1, nPublicParam2;
:DEFAULT nPublicParam1, 0;
:DEFAULT nPublicParam2, 100;
:DECLARE nLocal1, nLocal2, sLocalString;
:DECLARE aLocalArray, dLocalDate;
/* Test local variable declarations;
	nLocal1 := nPublicParam1 + nPublicParam2;
	nLocal2 := nLocal1 * 2;
	sLocalString := "Local variable";
	aLocalArray := {1, 2, 3, 4, 5};
	dLocalDate := Today();

:RETURN nLocal1;
:ENDPROC;

/* endregion;

/* region Type Conversion Tests;

:PROCEDURE TestTypeConversion;
:PARAMETERS vMixedValue;
:DECLARE nNumeric, sString, lLogical;
/* Type conversion functions;
	nNumeric := Val(vMixedValue);
	sString := Trim(vMixedValue);
	lLogical := .T.;

/* Bitwise operations;
	nNumeric := _AND(15, 7);
	nNumeric := _OR(8, 4);
	nNumeric := _XOR(12, 10);
	nNumeric := _NOT(5);

:RETURN nNumeric;
:ENDPROC;

/* endregion;

/* region Code Blocks and Anonymous Functions;

:PROCEDURE TestCodeBlocks;
:PARAMETERS aNumbers;
:DECLARE codeBlock, nResult;
/* Test code block literals;
	codeBlock := {|x| x * 2};

/* Apply code block to array evaluation;
	nResult := aeval(aNumbers, codeBlock);

/* More complex code block;
	codeBlock := {|x, y| x + y > 50};

:RETURN nResult;
:ENDPROC;

/* endregion;

/* region Return Statements and Procedure Exit;

:PROCEDURE TestReturnStatements;
:PARAMETERS nCondition;
:DECLARE nValue;
	nValue := 0;

/* Test early returns;
	:IF nCondition == 1;
	:RETURN 1;
	:ENDIF;

	:IF nCondition == 2;
	:RETURN 2;
	:ENDIF;

/* Default return;
:RETURN nValue;
:ENDPROC;

/* endregion;

/* region Label and Error Markers;

:PROCEDURE TestLabelsAndErrors;
:DECLARE nCounter;
	nCounter := 0;
	:LABEL StartLoop;
	nCounter := nCounter + 1;

	:IF nCounter < 10;
/* Process;
	:ENDIF;

	:IF nCounter >= 10;
		:ERROR "Counter exceeded limit";
	:ENDIF;

:RETURN nCounter;
:ENDPROC;

/* endregion;

/* region Class Definition Test (using :REGION keyword);

:REGION Class Definition;

	:CLASS TestDataModel;
		:INHERIT BaseModel;

		:DECLARE sClassName, nVersion, aProperties;
		:DECLARE bIsInitialized;

		:PROCEDURE Initialize;
		:PARAMETERS sName, nVer;
			sClassName := sName;
			nVersion := nVer;
			bIsInitialized := .T.;
			aProperties := {};
		:RETURN .T.;
		:ENDPROC;

		:PROCEDURE AddProperty;
		:PARAMETERS sPropertyName, vPropertyValue;
			aadd(aProperties, {sPropertyName, vPropertyValue});
		:RETURN Len(aProperties);
		:ENDPROC;

		:PROCEDURE GetProperty;
		:PARAMETERS sPropertyName;
		:DECLARE nIndex, vReturnValue;
			nIndex := ascan(aProperties, sPropertyName);
			:IF nIndex > 0;
				vReturnValue := aProperties[nIndex, 2];
			:ELSE;
				vReturnValue := NIL;
			:ENDIF;
		:RETURN vReturnValue;
		:ENDPROC;

		:PROCEDURE Validate;
			:IF .NOT. bIsInitialized;
				:ERROR "Object not initialized";
			:ENDIF;
		:RETURN .T.;
		:ENDPROC;

	:ENDREGION;

/* endregion;

/* region Complex Nested Control Flow;

	:PROCEDURE TestComplexControlFlow;
	:PARAMETERS nLevel;
	:DECLARE nCounter, bContinue;
		bContinue := .T.;
		nCounter := 0;

		:WHILE bContinue;
			:FOR nCounter := 1 :TO nLevel;
				:IF nCounter == 5;
					:BEGINCASE;
					:CASE nLevel > 10;
						nCounter := nCounter + 5;
					:CASE nLevel > 5;
						nCounter := nCounter + 2;
					:OTHERWISE;
						nCounter := nCounter + 1;
					:ENDCASE;
				:ENDIF;
			:NEXT;

			:IF nCounter > 50;
				bContinue := .F.;
			:ENDIF;
		:ENDWHILE;

	:RETURN nCounter;
	:ENDPROC;

/* endregion;

/* region System and Utility Functions;

	:PROCEDURE TestSystemFunctions;
	:DECLARE sEnvironment, nRecordCount, sDirectory, sNewId;
/* System information functions;
		sEnvironment := GetSetting("ENVIRONMENT");
		nRecordCount := 0;

/* User interaction;
		usrmes("Operation completed successfully");
		InfoMes("Process: " + Transform(Today()));

/* Directory operations;
		sDirectory := Directory("*.ssl");

/* GUID generation;
		sNewId := CreateGUID();

	:RETURN sEnvironment;
	:ENDPROC;

/* endregion;

/* region String Formatting and Building;

	:PROCEDURE TestStringBuilding;
	:PARAMETERS nCount, sPrefix;
	:DECLARE sResult, aStringParts;
/* Test string building functions;
		aStringParts := {};
		aadd(aStringParts, sPrefix);
		aadd(aStringParts, ": ");
		aadd(aStringParts, Transform(nCount));

/* Build string from array;
		sResult := buildstring(aStringParts, "");

/* Test string substitution;
		sResult := StrTran(sResult, ":", " equals ");

	:RETURN sResult;
	:ENDPROC;

/* endregion;

/* region Main Test Execution;

	:PROCEDURE FormatterComprehensiveTest;
	:DECLARE nTestsPassed, nTestsFailed, aTestResults, sErrorMessage;
	:DEFAULT nTestsPassed, 0;
	:DEFAULT nTestsFailed, 0;

		aTestResults := {};

/* Execute all tests;
		:TRY;
			aadd(aTestResults, TestIfElseNesting(50));
			aadd(aTestResults, TestForLoopWithStep({10, 20, 30}));
			aadd(aTestResults, TestWhileLoopWithExitwhile(10));
			aadd(aTestResults, TestLoopKeyword(5));
			aadd(aTestResults, TestCaseStatement("START"));
			aadd(aTestResults, TestBooleanAndNullValues());
			aadd(aTestResults, TestArraysAndStrings("test string"));
			aadd(aTestResults, TestDateAndTime());
			aadd(aTestResults, TestFunctionCalls(42));
			aadd(aTestResults, TestVariableDeclarations(10, 20));
			aadd(aTestResults, TestTypeConversion("123"));
			aadd(aTestResults, TestReturnStatements(1));
			aadd(aTestResults, TestLabelsAndErrors());
			aadd(aTestResults, TestComplexControlFlow(8));
			aadd(aTestResults, TestSystemFunctions());
			aadd(aTestResults, TestStringBuilding(42, "Count"));

			nTestsPassed := Len(aTestResults);
			usrmes("All " + Transform(nTestsPassed) + " tests completed");
		:CATCH;
			nTestsFailed := 1;
			sErrorMessage := GetLastSSLError();
			ErrorMes("Test failed: " + sErrorMessage);
		:FINALLY;
/* Test cleanup;
		:ENDTRY;

	:RETURN nTestsPassed;
	:ENDPROC;

/* endregion;

/*******************************************************************************
End of Comprehensive Formatter Test Document
*******************************************************************************/;
